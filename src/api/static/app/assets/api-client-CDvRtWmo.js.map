{"version":3,"file":"api-client-CDvRtWmo.js","sources":["../../../../ui/lib/api-client.ts"],"sourcesContent":["/**\n * Typed API client for openclaw-projects.\n *\n * Wraps fetch() with consistent error handling, base URL resolution,\n * and typed request/response methods. Auth is handled via session cookie\n * (no explicit token management needed).\n */\n\n/** Standard error shape returned by the API. */\nexport interface ApiError {\n  status: number;\n  message: string;\n  details?: unknown;\n}\n\n/** Custom error class for API failures. */\nexport class ApiRequestError extends Error {\n  public readonly status: number;\n  public readonly details?: unknown;\n\n  constructor(status: number, message: string, details?: unknown) {\n    super(message);\n    this.name = 'ApiRequestError';\n    this.status = status;\n    this.details = details;\n  }\n}\n\n/** Options for individual API requests. */\nexport interface RequestOptions {\n  /** AbortSignal for request cancellation. */\n  signal?: AbortSignal;\n  /** Additional headers to merge with defaults. */\n  headers?: Record<string, string>;\n}\n\n/**\n * Parse an API error response body into a structured error.\n * Falls back to a generic message if the body is not JSON.\n */\nasync function parseErrorResponse(res: Response): Promise<ApiRequestError> {\n  let message = `Request failed: ${res.status} ${res.statusText}`;\n  let details: unknown;\n\n  try {\n    const body = (await res.json()) as Record<string, unknown>;\n    if (typeof body.message === 'string') {\n      message = body.message;\n    }\n    if (typeof body.error === 'string') {\n      message = body.error;\n    }\n    details = body;\n  } catch {\n    // Response body is not JSON -- use default message\n  }\n\n  return new ApiRequestError(res.status, message, details);\n}\n\n/**\n * Typed API client singleton.\n *\n * All methods use the browser's built-in fetch and rely on session cookies\n * for authentication (same-origin requests).\n */\nexport const apiClient = {\n  /**\n   * Perform a GET request and return the parsed JSON body.\n   *\n   * @typeParam T - Expected response shape\n   * @param path - API path starting with `/api/...`\n   * @param opts - Optional request configuration\n   * @returns Parsed JSON response\n   * @throws {ApiRequestError} on non-2xx responses\n   */\n  async get<T>(path: string, opts?: RequestOptions): Promise<T> {\n    const res = await fetch(path, {\n      method: 'GET',\n      headers: {\n        accept: 'application/json',\n        ...opts?.headers,\n      },\n      signal: opts?.signal,\n    });\n\n    if (!res.ok) {\n      throw await parseErrorResponse(res);\n    }\n\n    return (await res.json()) as T;\n  },\n\n  /**\n   * Perform a POST request with a JSON body.\n   *\n   * @typeParam T - Expected response shape\n   * @param path - API path starting with `/api/...`\n   * @param body - Request body (will be serialised to JSON)\n   * @param opts - Optional request configuration\n   * @returns Parsed JSON response\n   * @throws {ApiRequestError} on non-2xx responses\n   */\n  async post<T>(path: string, body: unknown, opts?: RequestOptions): Promise<T> {\n    const res = await fetch(path, {\n      method: 'POST',\n      headers: {\n        'content-type': 'application/json',\n        accept: 'application/json',\n        ...opts?.headers,\n      },\n      body: JSON.stringify(body),\n      signal: opts?.signal,\n    });\n\n    if (!res.ok) {\n      throw await parseErrorResponse(res);\n    }\n\n    return (await res.json()) as T;\n  },\n\n  /**\n   * Perform a PUT request with a JSON body.\n   *\n   * @typeParam T - Expected response shape\n   * @param path - API path starting with `/api/...`\n   * @param body - Request body (will be serialised to JSON)\n   * @param opts - Optional request configuration\n   * @returns Parsed JSON response\n   * @throws {ApiRequestError} on non-2xx responses\n   */\n  async put<T>(path: string, body: unknown, opts?: RequestOptions): Promise<T> {\n    const res = await fetch(path, {\n      method: 'PUT',\n      headers: {\n        'content-type': 'application/json',\n        accept: 'application/json',\n        ...opts?.headers,\n      },\n      body: JSON.stringify(body),\n      signal: opts?.signal,\n    });\n\n    if (!res.ok) {\n      throw await parseErrorResponse(res);\n    }\n\n    return (await res.json()) as T;\n  },\n\n  /**\n   * Perform a PATCH request with a JSON body.\n   *\n   * @typeParam T - Expected response shape\n   * @param path - API path starting with `/api/...`\n   * @param body - Partial update body (will be serialised to JSON)\n   * @param opts - Optional request configuration\n   * @returns Parsed JSON response\n   * @throws {ApiRequestError} on non-2xx responses\n   */\n  async patch<T>(path: string, body: unknown, opts?: RequestOptions): Promise<T> {\n    const res = await fetch(path, {\n      method: 'PATCH',\n      headers: {\n        'content-type': 'application/json',\n        accept: 'application/json',\n        ...opts?.headers,\n      },\n      body: JSON.stringify(body),\n      signal: opts?.signal,\n    });\n\n    if (!res.ok) {\n      throw await parseErrorResponse(res);\n    }\n\n    return (await res.json()) as T;\n  },\n\n  /**\n   * Perform a DELETE request.\n   *\n   * @typeParam T - Expected response shape (often void / empty)\n   * @param path - API path starting with `/api/...`\n   * @param opts - Optional request configuration\n   * @returns Parsed JSON response (or undefined for 204 No Content)\n   * @throws {ApiRequestError} on non-2xx responses\n   */\n  async delete<T = void>(path: string, opts?: RequestOptions): Promise<T> {\n    const res = await fetch(path, {\n      method: 'DELETE',\n      headers: {\n        accept: 'application/json',\n        ...opts?.headers,\n      },\n      signal: opts?.signal,\n    });\n\n    if (!res.ok) {\n      throw await parseErrorResponse(res);\n    }\n\n    // 204 No Content has no body\n    if (res.status === 204) {\n      return undefined as T;\n    }\n\n    return (await res.json()) as T;\n  },\n};\n"],"names":["ApiRequestError","status","message","details","parseErrorResponse","res","body","apiClient","path","opts"],"mappings":"AAgBO,MAAMA,UAAwB,KAAM,CACzB,OACA,QAEhB,YAAYC,EAAgBC,EAAiBC,EAAmB,CAC9D,MAAMD,CAAO,EACb,KAAK,KAAO,kBACZ,KAAK,OAASD,EACd,KAAK,QAAUE,CACjB,CACF,CAcA,eAAeC,EAAmBC,EAAyC,CACzE,IAAIH,EAAU,mBAAmBG,EAAI,MAAM,IAAIA,EAAI,UAAU,GACzDF,EAEJ,GAAI,CACF,MAAMG,EAAQ,MAAMD,EAAI,KAAA,EACpB,OAAOC,EAAK,SAAY,WAC1BJ,EAAUI,EAAK,SAEb,OAAOA,EAAK,OAAU,WACxBJ,EAAUI,EAAK,OAEjBH,EAAUG,CACZ,MAAQ,CAER,CAEA,OAAO,IAAIN,EAAgBK,EAAI,OAAQH,EAASC,CAAO,CACzD,CAQO,MAAMI,EAAY,CAUvB,MAAM,IAAOC,EAAcC,EAAmC,CAC5D,MAAMJ,EAAM,MAAM,MAAMG,EAAM,CAC5B,OAAQ,MACR,QAAS,CACP,OAAQ,mBACR,GAAGC,GAAM,OAAA,EAEX,OAAQA,GAAM,MAAA,CACf,EAED,GAAI,CAACJ,EAAI,GACP,MAAM,MAAMD,EAAmBC,CAAG,EAGpC,OAAQ,MAAMA,EAAI,KAAA,CACpB,EAYA,MAAM,KAAQG,EAAcF,EAAeG,EAAmC,CAC5E,MAAMJ,EAAM,MAAM,MAAMG,EAAM,CAC5B,OAAQ,OACR,QAAS,CACP,eAAgB,mBAChB,OAAQ,mBACR,GAAGC,GAAM,OAAA,EAEX,KAAM,KAAK,UAAUH,CAAI,EACzB,OAAQG,GAAM,MAAA,CACf,EAED,GAAI,CAACJ,EAAI,GACP,MAAM,MAAMD,EAAmBC,CAAG,EAGpC,OAAQ,MAAMA,EAAI,KAAA,CACpB,EAYA,MAAM,IAAOG,EAAcF,EAAeG,EAAmC,CAC3E,MAAMJ,EAAM,MAAM,MAAMG,EAAM,CAC5B,OAAQ,MACR,QAAS,CACP,eAAgB,mBAChB,OAAQ,mBACR,GAAGC,GAAM,OAAA,EAEX,KAAM,KAAK,UAAUH,CAAI,EACzB,OAAQG,GAAM,MAAA,CACf,EAED,GAAI,CAACJ,EAAI,GACP,MAAM,MAAMD,EAAmBC,CAAG,EAGpC,OAAQ,MAAMA,EAAI,KAAA,CACpB,EAYA,MAAM,MAASG,EAAcF,EAAeG,EAAmC,CAC7E,MAAMJ,EAAM,MAAM,MAAMG,EAAM,CAC5B,OAAQ,QACR,QAAS,CACP,eAAgB,mBAChB,OAAQ,mBACR,GAAGC,GAAM,OAAA,EAEX,KAAM,KAAK,UAAUH,CAAI,EACzB,OAAQG,GAAM,MAAA,CACf,EAED,GAAI,CAACJ,EAAI,GACP,MAAM,MAAMD,EAAmBC,CAAG,EAGpC,OAAQ,MAAMA,EAAI,KAAA,CACpB,EAWA,MAAM,OAAiBG,EAAcC,EAAmC,CACtE,MAAMJ,EAAM,MAAM,MAAMG,EAAM,CAC5B,OAAQ,SACR,QAAS,CACP,OAAQ,mBACR,GAAGC,GAAM,OAAA,EAEX,OAAQA,GAAM,MAAA,CACf,EAED,GAAI,CAACJ,EAAI,GACP,MAAM,MAAMD,EAAmBC,CAAG,EAIpC,GAAIA,EAAI,SAAW,IAInB,OAAQ,MAAMA,EAAI,KAAA,CACpB,CACF"}